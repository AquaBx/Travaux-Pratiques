---
title: "Compte-rendu TP √âquations Diff√©rentielles"
format: 
  typst:
    toc: true
    section-numbering: "1.a :"
    author: Tom Chauvel
    keep-typ: true

render-on-save: true

engine: jupyter
jupyter: python3
---


```{=typst}
#pagebreak();
```

Dans ce TP nous allons voir comment manipuler les √©quations diff√©rentielles, en particulier comment les approximer num√©riquement avec la m√©thode d'Euler et celle de Runge-Kutta.

# Partie 1

## Compl√©tion du fichier

```{python}
import numpy as np
from matplotlib import pyplot as plt
```
``` python
tmax = 20  # dur√©e simulation
pas = 0.5 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique
#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))
#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x[i]=x[i-1]+pas*f1
#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Euler')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```

```{=typst}

#pagebreak()
```

## Etude de l‚Äôinfluence du pas de simulation ùõº

``` {python}
#| fig-cap: "cas ùõº=0.2"
#| echo : false

tmax = 20  # dur√©e simulation
pas = 0.2 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique
#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))
#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x[i]=x[i-1]+pas*f1
#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Euler')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```


``` {python}
#| fig-cap: "cas ùõº=0.5"
#| echo : false

tmax = 20  # dur√©e simulation
pas = 0.5 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique
#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))
#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x[i]=x[i-1]+pas*f1
#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Euler')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```
``` {python}
#| fig-cap: "cas ùõº=0.8"
#| echo : false

tmax = 20  # dur√©e simulation
pas = 0.8 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique
#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))
#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x[i]=x[i-1]+pas*f1
#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Euler')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```

En changeant le pas, la solution est approch√© plus ou moins pr√©cisement. En l'occurence, plus le pas est petit plus on est pr√©cis.

```{=typst}
#pagebreak()
```

## Programmation de la m√©thode de Runge-Kutta d‚Äôordre 2

```python
tmax = 20  # dur√©e simulation
pas = 0.5 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique

#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))

#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x1 = x[i-1]+pas*f1
        f2 = -x1

        x[i] = x[i-1] + pas*(f1+f2)/2

#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Runge-Kutta')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```

```{=typst}
#pagebreak()
```

## Comparaison des deux m√©thodes

```{python}
#| fig-cap: "M√©thode Runge-Kutta cas ùõº=0.2"
#| echo : false

tmax = 20  # dur√©e simulation
pas = 0.2 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique

#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))

#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x1 = x[i-1]+pas*f1
        f2 = -x1

        x[i] = x[i-1] + pas*(f1+f2)/2

#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Runge-Kutta')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```
```{python}
#| fig-cap: "M√©thode Runge-Kutta cas ùõº=0.5"
#| echo : false

tmax = 20  # dur√©e simulation
pas = 0.5 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique

#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))

#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x1 = x[i-1]+pas*f1
        f2 = -x1

        x[i] = x[i-1] + pas*(f1+f2)/2

#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Runge-Kutta')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```

```{python}
#| fig-cap: "M√©thode Runge-Kutta cas ùõº=0.8"
#| echo : false

tmax = 20  # dur√©e simulation
pas = 0.8 # pas d'Euler
time=np.arange(0, tmax, pas) # Discr√©tisation

#--------Courbe r√©elle---------
x_th=np.zeros(len(time))
x_th=np.exp(-time) #solution th√©orique

#--------------------
x0 = 1 #condition initiale
x = np.zeros(len(x_th))
f1 = np.zeros(len(x_th))

#------------simul Euler-------------------------
for i in range(len(time)):
    if i==0: #v√©rification condition initiale
        x[i]=x0
    else:
        f1 = -x[i-1]
        x1 = x[i-1]+pas*f1
        f2 = -x1

        x[i] = x[i-1] + pas*(f1+f2)/2

#--------------------------------
plt.figure()
#---------visu ---------
plt.plot(time  ,x_th, label='Theoric')
plt.plot(time  ,x,'-..', label='Runge-Kutta')
plt.xlabel ('temps')
plt.ylabel('x(t)')
plt.grid()
plt.legend()
plt.show()
```

On remarque qu'√† pas √©gal, Runge-Kutta est plus pr√©cis. De plus, √† l'inverse de la m√©thode de Euler qui se rapproche via le bas, le rapprochement de la courbe vient du haut.


```{=typst}
#pagebreak()
```

# Partie 2

## Analyse

‚ÑéùëÖ(ùë°)     : renard isol√© / renard qui vont disparaitre 
ùëèùëÖ(ùë°)ùêø(ùë°) : renard qui ont de quoi se nourrir et qui vont survivre

ùëéùêø(ùë°)     : lapin qui n'ont pas crois√© de renard et qui vont survivre
ùëêùëÖ(ùë°)ùêø(ùë°) : lapin qui ont crois√© un renard et qui vont mourir

```{=typst}
#pagebreak()
```

## Codage M√©thode Euler
```python
#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.2             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    f1 = -c*R[i]*L[i] + a * L[i]
    f2 = - h * R[i] + b*R[i]*L[i]
    L[i+1]=L[i]+pas*f1
    R[i+1]=R[i]+pas*f2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```



```{python}
#| fig-cap: "M√©thode Euler cas pas=0.1"
#| echo : false

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.1             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    f1 = -c*R[i]*L[i] + a * L[i]
    f2 = - h * R[i] + b*R[i]*L[i]
    L[i+1]=L[i]+pas*f1
    R[i+1]=R[i]+pas*f2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```


```{python}
#| fig-cap: "M√©thode Euler cas pas=0.3"
#| echo : false

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.3             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    f1 = -c*R[i]*L[i] + a * L[i]
    f2 = - h * R[i] + b*R[i]*L[i]
    L[i+1]=L[i]+pas*f1
    R[i+1]=R[i]+pas*f2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```



```{python}
#| fig-cap: "M√©thode Euler cas pas=0.4"
#| echo : false

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.4             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    f1 = -c*R[i]*L[i] + a * L[i]
    f2 = - h * R[i] + b*R[i]*L[i]
    L[i+1]=L[i]+pas*f1
    R[i+1]=R[i]+pas*f2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```



```{python}
#| fig-cap: "M√©thode Euler cas pas=0.5"
#| echo : false

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.5             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    f1 = -c*R[i]*L[i] + a * L[i]
    f2 = - h * R[i] + b*R[i]*L[i]
    L[i+1]=L[i]+pas*f1
    R[i+1]=R[i]+pas*f2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```

Plus le pas augmente plus la courbe perd des d√©tail et deviens de plus en plus fausse, surtout √† partir de 0.5.

```{=typst}
#pagebreak()
```

## Codage Runge-Kutta

```python

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.5             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    
    r1 = R[i]
    l1 = L[i]

    fl1 = - c * r1 * l1 + a * l1
    fr1 = - h * r1 + b * r1 * l1

    l2=l1+pas*fl1
    r2=r1+pas*fr1

    fl2 = - c * r2 * l2 + a * l2
    fr2 = - h * r2 + b * r2 * l2

    L[i+1]=L[i]+pas*(fl1+fl2)/2
    R[i+1]=R[i]+pas*(fr1+fr2)/2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```


```{python}
#| fig-cap: "M√©thode Runge-Kutta cas pas=0.5"
#| echo : false

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.5             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    
    r1 = R[i]
    l1 = L[i]

    fl1 = - c * r1 * l1 + a * l1
    fr1 = - h * r1 + b * r1 * l1

    l2=l1+pas*fl1
    r2=r1+pas*fr1

    fl2 = - c * r2 * l2 + a * l2
    fr2 = - h * r2 + b * r2 * l2

    L[i+1]=L[i]+pas*(fl1+fl2)/2
    R[i+1]=R[i]+pas*(fr1+fr2)/2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```


```{python}
#| fig-cap: "M√©thode Runge-Kutta cas pas=0.6"
#| echo : false

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.6             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    
    r1 = R[i]
    l1 = L[i]

    fl1 = - c * r1 * l1 + a * l1
    fr1 = - h * r1 + b * r1 * l1

    l2=l1+pas*fl1
    r2=r1+pas*fr1

    fl2 = - c * r2 * l2 + a * l2
    fr2 = - h * r2 + b * r2 * l2

    L[i+1]=L[i]+pas*(fl1+fl2)/2
    R[i+1]=R[i]+pas*(fr1+fr2)/2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```


```{python}
#| fig-cap: "M√©thode Runge-Kutta cas pas=0.7"
#| echo : false

#--Simul mod√®le Lotka-Voltterra--------------

a= 0.4 # taux de croissance proies en absence pr√©dateurs
h= 0.4 # taux d√©c√®s pr√©dateurs en l'absence de proies
b= 0.01 # influence pr√©dateurs sur proies
c= 0.01 # influence proies sur pr√©dateurs


tmax = 40  # dur√©e simulation
pas = 0.7             # pas d'Euler
nmax=round(tmax/pas) # nombre √©chantillons simul√©s
#--------initialisations---------
R=np.zeros(nmax)
L=np.zeros(nmax)

L[0]=80 #Initialisation Lapins
R[0]=12 #Initialisation Renards

#------------simul Euler-------------------------
for i in range(nmax-1):
    
    r1 = R[i]
    l1 = L[i]

    fl1 = - c * r1 * l1 + a * l1
    fr1 = - h * r1 + b * r1 * l1

    l2=l1+pas*fl1
    r2=r1+pas*fr1

    fl2 = - c * r2 * l2 + a * l2
    fr2 = - h * r2 + b * r2 * l2

    L[i+1]=L[i]+pas*(fl1+fl2)/2
    R[i+1]=R[i]+pas*(fr1+fr2)/2

#--------------------------------
plt.figure()
time = np.arange(nmax)
plt.subplot (2,1,1)
#---------visu Nbre Gentils (proies)---------
plt.plot(time  ,L)
plt.title("algo")
limit1 = plt.axis()
plt.xlabel('temps')
plt.ylabel('Nbre de proies')
plt.grid()

plt.legend('Proies')
#---------visu Nbre M√©chants (pr√©dateurs)--------
plt.subplot(2,1,2)
plt.plot(time  ,R,'-..')
plt.xlabel('temps')
plt.ylabel('Nbre de Pr√©dateurs')
plt.grid()
plt.legend('Pr√©dateurs')

plt.show()
```

On remarque qu'aucun changement majeur n'apparait sur les courbes, et m√™me que les r√©sultats sont meilleurs qu'avec la m√©thode d'Euler.

# Conclusion

Ce TP a pu nous familiariser aux m√©thodes d'analyse num√©rique des √©quations diff√©rentielles. Nous avons pu constater que la m√©thode de Runge-Kutta est bien souvent plus qualitative √† un pas donn√© et perd moins de d√©tail avec un pas de plus en plus grand. 